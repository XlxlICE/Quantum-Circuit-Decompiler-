# Quantum-Circuit-Decompiler-
Circuit decompilation entails the reverse engineering of digital logic circuits to reconstitute a high-level representation
that approximates the original design, usually articulated in hardware description languages. In this project, we will
explore methods to implement quantum circuit decompilation, focusing specifically on inferring shared structures in
a set of circuits. The high-level compressed description of this set of circuits of an algorithm would then be used
to generate circuits of new problem sizes to test the generalization capability of the abstracted explanation. The
decompiler will be tested on algorithm-generated quantum circuits and hardware-optimized versions of these circuits
to investigate the explainability-efficiency trade-off.


# Quantum Circuit Decompiler for Scalable Quantum Architecture Search

The following steps outline the process for developing a quantum circuit decompiler aimed at scalable quantum architecture search:

- Fix a quantum conventional algorithm `A` of your choice (some ideas: [different types of quantum adders](https://github.com/Qiskit/qiskit/tree/main/qiskit/circuit/library/arithmetic/adders), [quantum fourier transform](https://github.com/cda-tum/mqt-bench/blob/main/src/mqt/bench/benchmarks/qft.py), [quantum phase estimation](https://github.com/cda-tum/mqt-bench/blob/main/src/mqt/bench/benchmarks/qpeexact.py), [grover search](https://github.com/cda-tum/mqt-bench/blob/main/src/mqt/bench/benchmarks/grover.py), etc.). Generate quantum circuits for `A` for different problem sizes, e.g., from 2 to 20 qubits. These circuits are generated by a Qiskit/Python program `P_A(n)`. And the circuits are `C_A^2, C_A^3, ... C_A^20`.

- This set of circuits `C_A^n` is the data set. Given this set, `C_A^n` as input, the **decompiler** we design should be able to build a program `P'_A(n)`, which is close to `P_A(n)`.

- `P_A(n)` can then be used to generate `C'_A^21, C'_A^22, ...` and we can compare how close they are to `C_A^21, C_A^22, ...`. This is for validating the *generalisation* capability.

- Take circuits `C_A^n` and translate them to the corresponding unitaries, `U_A^n`.

- Decompose these unitaries using Qiskit to the native gate set of a QPU (say, IBM) to get circuits `C'_A^n`. This optimization is the **recompiler**. We can use [Quantum Shannon Decomposition](https://docs.quantum.ibm.com/api/qiskit/synthesis#qs_decomposition) or its [approximate version](https://docs.quantum.ibm.com/api/qiskit/qiskit.synthesis.unitary.aqc#approximate-quantum-compiler) from Qiskit.

- Given this set of circuits `C'_A^n`, use the **decompiler** to infer `P''_A(n)`.

- `C'_A^n` is more hardware-efficient than `C_A^n`. However, we expect `P''_A(n)` is less explainable/abstract than `P'_A(n)`, and thus more different from `P_A(n)`. That is, it is harder to generalize from optimized circuits. We can test that by checking if `C''_A^21, C''_A^22, ...` have lower process fidelity than `C'_A^21, C'_A^22, ...`, with respect to `C_A^21, C_A^22, ...`. This is the exploration of the *explainability-efficiency trade-off*.

